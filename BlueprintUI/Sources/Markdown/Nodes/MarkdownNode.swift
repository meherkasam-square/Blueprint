//
//  Node.swift
//  Down
//
//  Created by John Nguyen on 07.04.19.
//

import Foundation
import libcmark

/// A node is a wrapper of a raw `CMarkNode` belonging to the abstract syntax tree
/// generated by cmark.

public protocol MarkdownNode {

    /// The wrapped node.

    var cmarkNode: CMarkNode { get }

    /// The wrapped child nodes.

    var children: [MarkdownNode] { get }

}

extension MarkdownNode {

    /// True iff the node has a sibling that succeeds it.

    public var hasSuccessor: Bool {
        cmark_node_next(cmarkNode) != nil
    }

    /// Sequence of wrapped child nodes.

    public var childSequence: ChildSequence {
        ChildSequence(node: cmarkNode)
    }

}

// MARK: - Helper extensions

public typealias CMarkNode = UnsafeMutablePointer<cmark_node>

extension CMarkNode {

    /// Wraps the cmark node referred to by this pointer.

    public func wrap() -> MarkdownNode? {
        switch type {
        case CMARK_NODE_DOCUMENT: return DocumentNode(cmarkNode: self)
        case CMARK_NODE_BLOCK_QUOTE: return BlockQuoteNode(cmarkNode: self)
        case CMARK_NODE_LIST: return ListNode(cmarkNode: self)
        case CMARK_NODE_ITEM: return ItemNode(cmarkNode: self)
        case CMARK_NODE_CODE_BLOCK: return CodeBlock(cmarkNode: self)
        case CMARK_NODE_HTML_BLOCK: return HtmlBlockNode(cmarkNode: self)
        case CMARK_NODE_CUSTOM_BLOCK: return CustomBlockNode(cmarkNode: self)
        case CMARK_NODE_PARAGRAPH: return ParagraphNode(cmarkNode: self)
        case CMARK_NODE_HEADING: return HeadingNode(cmarkNode: self)
        case CMARK_NODE_THEMATIC_BREAK: return ThematicBreakNode(cmarkNode: self)
        case CMARK_NODE_TEXT: return TextNode(cmarkNode: self)
        case CMARK_NODE_SOFTBREAK: return SoftBreakNode(cmarkNode: self)
        case CMARK_NODE_LINEBREAK: return LineBreakNode(cmarkNode: self)
        case CMARK_NODE_CODE: return CodeNode(cmarkNode: self)
        case CMARK_NODE_HTML_INLINE: return HtmlInlineNode(cmarkNode: self)
        case CMARK_NODE_CUSTOM_INLINE: return CustomInlineNode(cmarkNode: self)
        case CMARK_NODE_EMPH: return EmphasisNode(cmarkNode: self)
        case CMARK_NODE_STRONG: return StrongNode(cmarkNode: self)
        case CMARK_NODE_LINK: return LinkNode(cmarkNode: self)
        case CMARK_NODE_IMAGE: return ImageNode(cmarkNode: self)
        default: return nil
        }
    }

    public var parent: CMarkNode? {
        cmark_node_parent(self)
    }

    public var type: cmark_node_type {
        cmark_node_get_type(self)
    }

    public var literal: String? {
        String(cString: cmark_node_get_literal(self))
    }

    public var fenceInfo: String? {
        String(cString: cmark_node_get_fence_info(self))
    }

    public var headingLevel: Int {
        Int(cmark_node_get_heading_level(self))
    }

    public var listType: cmark_list_type {
        cmark_node_get_list_type(self)
    }

    public var listStart: Int {
        Int(cmark_node_get_list_start(self))
    }

    public var listDelimiter: cmark_delim_type {
        cmark_node_get_list_delim(self)
    }

    public var url: String? {
        String(cString: cmark_node_get_url(self))
    }

    public var title: String? {
        String(cString: cmark_node_get_title(self))
    }
}

extension String {

    fileprivate init?(cString: UnsafePointer<Int8>?) {
        guard let unwrapped = cString else { return nil }
        let result = String(cString: unwrapped)
        guard !result.isEmpty else { return nil }
        self = result
    }

}
